<h1>Django ORM</h1>

<p align="center">
<img width="600px" src="https://user-images.githubusercontent.com/31994778/156621497-70d7aa7f-3183-4e15-b91c-26cd191ec83b.png">

  [ref](https://swapps.com/blog/quick-start-with-django-orm/)
 </p>
 
 <b><i>"Django ORM is a wrapper for SQL, enabling developers to use Python language for SQL queries."</i></b>
 
 ---
 
<b>Table Of Contents</b> |
------------ | 
[Introduction migrations](#intro-to-migrations)
[Unapplying migrations](#unapplying-migrations)
[Creating our model](#creating-our-model)
[Inserting our first data](#inserting-data)

---

<div id="intro-to-migrations">
  <h2>Introduction to Migrations</h2>
  </div>
  
<b>Migrations are the tools for creating and modifying database tables without having to learn SQL language.</b>[ref](https://realpython.com/lessons/what-django-migrations-and-problems-they-solve/)

All database systems supported by Django use SQL to handle CRUD operations in a relational db.

Django orm(object relational mapper) is a mapper that maps Python objects (models) to SQL tables. Using Django orm, we don't have to use SQL to create database tables.

Here, we have a model `PriceHistory` and it's fields mapped to db as a table and it's columns.

<img width="600px" src="https://user-images.githubusercontent.com/31994778/156626713-c5c05367-7e50-48c1-bf79-ba3c3444b99f.png">

>But just defining a model class in a Python file does not make a database table magically appear out of nowhere. Creating the database tables to store your Django models is the job of a database migration. Additionally, whenever you make a change to your models, like adding a field, the database has to be changed too. Migrations handle that as well. [ref](https://realpython.com/django-migrations-a-primer/#the-problems-that-migrations-solve)

Here are a few ways Django migrations make your life easier.

<h3>Making database changes without SQL</h3>

In traditional SQL, if you want to make changes on your db tables, you'd have to write more SQL codes. (This is what I've read on the internet, not that I know SQL :)) However, with migrations, you can easily change your db models with plain Python coding. We only have to run `python manage.py makemigrations` to make database changes effective.

<b>We can also run `makemigrations` and `migrate` for a specific app as:</b>

`python3 manage.py makemigrations demo_orm_app`

`python3 manage.py migrate demo_orm_app`

When created, the database tables can be check through `dbshell` as:

```py
$ python3 manage.py dbshell
SQLite version 3.24.0 2018-06-04 14:10:15
Enter ".help" for usage hints.
sqlite> .tables
auth_group                  demo_orm_app_person       
auth_group_permissions      django_admin_log          
auth_permission             django_content_type       
auth_user                   django_migrations         
auth_user_groups            django_session            
auth_user_user_permissions
```
If we do these only for a specific app, though,

```py
sqlite> .tables
demo_orm_app_person  django_migrations
```

<b>Here, `demo_orm_app_person` is the table that we created with our `Person` model.</b>

We can get more info about the table we want through `.schema --indent <table name>`.

<img width="659" alt="Screen Shot 2022-03-05 at 11 59 25 AM" src="https://user-images.githubusercontent.com/31994778/156876494-9b70a0ea-3af2-4784-8b8c-8b6d4c92afe7.png">

`--indent` is used to format output nicely.

In order to display migrations of other apps, we can do `python3 manage.py showmigrations`

<img width="655" alt="Screen Shot 2022-03-05 at 12 40 46 PM" src="https://user-images.githubusercontent.com/31994778/156877844-6c7e0469-953e-4850-9f5f-0dc602415b56.png">

<div id="unapplying-migrations">
  <h3>Unapplying migrations</h3>
  </div>



<h3>makemigrations vs migrate</h3>

These two commands can be easily mixed up. To clarify, we can say that:

- `makemigrations` will look for changes in models.py, if there's a change, it will apply, if not it will say `No changes detected`.
- `migrate` will implement migration. 

These can be shown as follows:

<img width="684" alt="Screen Shot 2022-03-05 at 11 43 45 AM" src="https://user-images.githubusercontent.com/31994778/156875808-f92878cf-40a8-4585-bd7d-1a0ecc3673f3.png">

---

<div id="creating-our-model">
  <h2>Creating our model</h2>
  </div>
  
 Let's have `Person` model(table).
 
 ```py
 class Person(models.Model):
    class GenderChoices(models.TextChoices):
        male = 'M'
        female = 'F'

    name = models.CharField(max_length=50)
    age = models.PositiveIntegerField()
    gender = models.CharField(max_length=1, choices=GenderChoices.choices)
    
    class Meta:
        unique_together = ('name', 'age') 
 ```
 
 After we make our migrations by `python manage.py makemigrations`, we will have a python file `0001_initial.py` like this.
 
 ```py
 # Generated by Django 3.2.6 on 2022-03-03 18:34

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Person',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=50)),
                ('age', models.PositiveIntegerField()),
                ('gender', models.CharField(choices=[('M', 'Male'), ('F', 'Female')], max_length=1)),
            ],
        ),
    ]
```

The more changes (and migrations after) we make, the more `*?_initial.py` files we would have. For the second migration we make, we'll have 0002_foo_bar.py...

For example, we added `unique_together` to `name` and `age` fields and makemigrations again. We will have the following .py file.

<img width="333" alt="Screen Shot 2022-03-03 at 11 09 47 PM" src="https://user-images.githubusercontent.com/31994778/156644801-ddd401f8-8e1a-4f02-84f0-2ba44a55c6b8.png">

<b>Here, important thing to notice is that every subsequent migration creates a new python file and they stack. (By stack, we mean that each subsequent file inherit from the previous migration's .py file)</b>

---

<div id="inserting-data">
<h2>Inserting our first data</h2>
  </div>
  
  Making migrations are just a way of creating tables and schema for our database. We can create real data through django's views and serializers.
  
  Here, we create a serializer in accordance with our Person model.
  
  <img width="442" alt="Screen Shot 2022-03-05 at 11 09 19 AM" src="https://user-images.githubusercontent.com/31994778/156874741-2c9d4139-2c21-4e68-8a5d-ad1e74c04f05.png">

  This means that we will validate `name`, `age`, and `gender` fields.
  
  Also, we need to have an API (view file), helping us persist data in database.
  
  <img width="575" alt="Screen Shot 2022-03-05 at 11 10 46 AM" src="https://user-images.githubusercontent.com/31994778/156874856-6dbebd4a-9113-4c82-9de3-8f90201d6407.png">

  Sending data through our endpoint, `demo_orm/user/create/`, 
  
  We have data in our database as follows:
  
  <img width="501" alt="Screen Shot 2022-03-05 at 11 17 32 AM" src="https://user-images.githubusercontent.com/31994778/156875002-c9a1a03b-13ef-416f-a3ce-953a3df888f4.png">

<b>It's important that we have a serializer, which let's us return 400 immediately if sent data is incompatible with data we expect</b>.

For example, if we send `age` less than zero,

<img width="756" alt="Screen Shot 2022-03-05 at 11 26 42 AM" src="https://user-images.githubusercontent.com/31994778/156875267-9079414a-0234-4881-b54f-c42e0b4e6c15.png">


---

